/*
 * Copyright (C) 2014-2019 halo https://github.com/halo/macosvpn
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import Darwin
import SystemConfiguration

open class ServiceConfig {
  public enum Kind: String {
    case L2TPOverIPSec
    case CiscoIPSec
  }

  // **************
  // INITIALIZATION
  // **************

  public init(kind: Kind, name: String, endpoint: String) {
    self.kind = kind
    self.name = name
    self.endpoint = endpoint
  }

  // **********
  // ATTRIBUTES
  // **********

  public var kind: Kind
  public var humanKind: String {
    switch kind {
    case .L2TPOverIPSec: return "L2TP over IPSec"
    case .CiscoIPSec: return "Cisco IPSec"
    }
  }

  // Assigned on-the-fly once generated by the OS
  public var serviceID: String?
  
  // Apply to both L2TP and Cisco
  public var name: String
  public var endpoint: String
  public var username: String?
  public var password: String?
  public var sharedSecret: String?
  public var localIdentifier: String?
  
  // L2TP-specific
  public var enableSplitTunnel: Bool = false
  public var disconnectOnSwitch: Bool = false
  public var disconnectOnLogout: Bool = false
  
  // ****************
  // INSTANCE METHODS
  // ****************

  public var description: String {
    var result = ["<[ServiceConfig \(kind)]"]

    result.append("name=\(name)")
    result.append("endpoint=\(endpoint)")
    if username != nil { result.append("username=\(username ?? "nil")") }
    if password != nil { result.append("password=\(password ?? "nil")") }
    if sharedSecret != nil { result.append("sharedSecret=\(sharedSecret ?? "nil")") }
    if localIdentifier != nil { result.append("localIdentifier=\(localIdentifier ?? "nil")") }

    if kind == .L2TPOverIPSec {
      result.append("enableSplitTunnel=\(enableSplitTunnel)")
      result.append("disconnectOnSwitch=\(disconnectOnSwitch)")
      result.append("disconnectOnLogout=\(disconnectOnLogout)")
    }

    return result.joined(separator: " ") + ">"
  }
  
  public var l2TPPPPConfig: CFDictionary {
    guard kind == .L2TPOverIPSec else {
      Log.error("l2TPPPPConfig is only available for L2TP over IPSec")
      exit(ExitCode.invalidServiceKindCalled.rawValue)
    }

    Log.info("Assembling l2TPPPPConfig configuration dictionary...")
    var result: [CFString: Any?] = [:]

    result.updateValue(endpoint as CFString?,
                       forKey: kSCPropNetPPPCommRemoteAddress)

    result.updateValue(username as CFString?,
                       forKey: kSCPropNetPPPAuthName)

    result.updateValue(serviceID as CFString?,
                       forKey: kSCPropNetPPPAuthPassword)

    result.updateValue(kSCValNetPPPAuthPasswordEncryptionKeychain,
                       forKey: kSCPropNetPPPAuthPasswordEncryption)

    var switchOne = disconnectOnSwitch ? 1 : 0
    let switchOneRef = CFNumberCreate(nil, .sInt8Type, &switchOne)

    result.updateValue(switchOneRef,
                       forKey: kSCPropNetPPPDisconnectOnFastUserSwitch)

    // Again, not sure if CFString or CFNumber is recommended.
    var logoutOne = disconnectOnLogout ? 1 : 0
    let logoutOneRef = CFNumberCreate(nil, .sInt8Type, &logoutOne)

    result.updateValue(logoutOneRef,
                       forKey: kSCPropNetPPPDisconnectOnLogout)

    Log.info("l2TPIPSecConfig ready: \(result)")
    return result as CFDictionary
  }
  
  public var l2TPIPSecConfig: CFDictionary {
    guard kind == .L2TPOverIPSec else {
      Log.error("l2TPIPSecConfig is only available for L2TP over IPSec")
      exit(ExitCode.invalidServiceKindCalled.rawValue)
    }

    Log.info("Assembling l2TPIPSecConfig configuration dictionary...")
    var result: [CFString: CFString?] = [:]

    result.updateValue(kSCValNetIPSecAuthenticationMethodSharedSecret,
                       forKey: kSCPropNetIPSecAuthenticationMethod)

    result.updateValue(kSCValNetIPSecSharedSecretEncryptionKeychain,
                       forKey: kSCPropNetIPSecSharedSecretEncryption)

    guard let unwrappedServiceID = serviceID else {
      Log.error("Could not unwrap the ServiceID")
      exit(999)
    }

    result.updateValue("\(unwrappedServiceID).SS" as CFString,
                       forKey: kSCPropNetIPSecSharedSecret)

    if (localIdentifier) != nil {
      Log.info("Assigning group name \(String(describing: localIdentifier)) to L2TP service config")

      result.updateValue(localIdentifier as CFString?,
                         forKey: kSCPropNetIPSecLocalIdentifier)

      result.updateValue(kSCValNetIPSecLocalIdentifierTypeKeyID,
                         forKey: kSCPropNetIPSecLocalIdentifierType)

    }

    Log.info("l2TPIPSecConfig ready: \(result)")

    return result as CFDictionary
  }

  public var l2TPIPv4Config: CFDictionary {
    guard kind == .L2TPOverIPSec else {
      Log.error("l2TPIPv4Config is only available for L2TP over IPSec")
      exit(ExitCode.invalidServiceKindCalled.rawValue)
    }

    Log.info("Assembling l2TPIPv4Config configuration dictionary...")
    var result: [CFString: Any?] = [:]

    result.updateValue(kSCValNetIPv4ConfigMethodPPP,
                       forKey: kSCPropNetIPv4ConfigMethod)

    if !enableSplitTunnel {
      var one = 1
      let oneRef = CFNumberCreate(nil, .sInt8Type, &one)

      result.updateValue(oneRef,
                         forKey: kSCPropNetOverridePrimary)
    }

    Log.info("l2TPIPv4Config ready: \(result)")

    return result as CFDictionary
  }

  public var ciscoIPv4Config: CFDictionary {
    guard kind == .CiscoIPSec else {
      Log.error("ciscoConfig is only available for Cisco IPSec")
      exit(ExitCode.invalidServiceKindCalled.rawValue)
    }

    Log.info("Assembling ciscoIPv4Config configuration dictionary...")
    var result: [CFString: CFString?] = [:]

    result.updateValue(kSCValNetIPv4ConfigMethodAutomatic,
                       forKey: kSCPropNetIPv4ConfigMethod)


    Log.info("ciscoIPv4Config ready: \(result)")

    return result as CFDictionary
  }

  public var ciscoConfig: CFDictionary {
    guard kind == .CiscoIPSec else {
      Log.error("ciscoConfig is only available for Cisco IPSec")
      exit(ExitCode.invalidServiceKindCalled.rawValue)
    }

    Log.info("Assembling ciscoConfig configuration dictionary...")
    var result: [CFString: CFString?] = [:]

    result.updateValue(kSCValNetIPSecAuthenticationMethodSharedSecret,
                       forKey: kSCPropNetIPSecAuthenticationMethod)

    guard let unwrappedServiceID = serviceID else {
      Log.error("Could not unwrap the ServiceID")
      exit(999)
    }
    
    result.updateValue("\(unwrappedServiceID).SS" as CFString,
                       forKey: kSCPropNetIPSecSharedSecret)

    result.updateValue(kSCValNetIPSecSharedSecretEncryptionKeychain,
                       forKey: kSCPropNetIPSecSharedSecretEncryption)

    result.updateValue(endpoint as CFString?,
                       forKey: kSCPropNetIPSecRemoteAddress)

    result.updateValue(username as CFString?,
                       forKey: kSCPropNetIPSecXAuthName)

    result.updateValue("\(unwrappedServiceID).XAUTH" as CFString,
                       forKey: kSCPropNetIPSecXAuthPassword)

    result.updateValue(kSCValNetIPSecXAuthPasswordEncryptionKeychain,
                       forKey: kSCPropNetIPSecXAuthPasswordEncryption)

    if (localIdentifier) != nil {
      Log.info("Assigning group name \(String(describing: localIdentifier)) to Cisco service config")

      result.updateValue(localIdentifier as CFString?,
                         forKey: kSCPropNetIPSecLocalIdentifier)

      result.updateValue(kSCValNetIPSecLocalIdentifierTypeKeyID,
                         forKey: kSCPropNetIPSecLocalIdentifierType)
    }

    Log.info("ciscoConfig ready: \(result)")

    return result as CFDictionary
  }
}

